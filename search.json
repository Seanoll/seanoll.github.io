[{"title":"build_blog","url":"/2026/02/12/build-blog/","content":"环境准备\n安装Node.js\n安装Git\n\ngit -vnode -vnpm -v\n搭建Hexo\n安装Hexo\n\nnpm install -g hexo-cli\n\n初始化博客\n\n# 创建并进入文件夹mkdir my-blogcd my-blog# 初始化 Hexohexo init# 安装依赖包npm install\n\n本地预览\n\nhexo s\n部署到Github Pages\n创建Github仓库，名字为：你的Github用户名.github.io\n配置Hexo部署信息，打开本地博客根目录下的 _config.yml文件，找到最底部的 deploy字段\n\n# Deploymentdeploy:   type: git   repo: git@github.com:Seanoll/seanoll.github.io.git   # ssh连接比http快，也可用：   # repo: https://github.com/你的GitHub用户名/你的GitHub用户名.github.io.git   branch: master \n\n安装部署插件\n\nnpm install hexo-deployer-git --savehexo d\n\n回到Github仓库页面，点击Settings -&gt; Pages， 在 Source下拉菜单中，选择 Deploy from a branch，然后选择刚才配置的分支（如 main或 master），点击 Save\n\n内容\n在Hexo官网或者Github上找主题，下载到themes文件夹或者git clone \n在博客根目录下的_config.yml中下拉找到theme改为theme: 什么名字\n在主题的source文件夹里修改配置文件\n使用hexo new 文章名来新建一篇文章，找到并编辑它，写好之后保存\n使用hexo new page 网页名来新建一张页面\n使用hexo g来生成相应的文件，使用hexo d部署更新到网站上\n\n在配置过程中出现版本问题\n在命令行里无法删除一个文件夹Permission Denied可能是因为该文件夹在图形化界面中打开。\nhexo init必须初始化一个空文件夹，如果已经删干净了还是提示有文件，使用ls -a来查看隐藏文件并删除。 \ngit clone或者wget和curl速度太慢时，将网络代理设置成全局模式。\n在 YAML 中，冒号 :后面必须有一个空格。branch:master应该写为 branch: master。非末尾的后大括号后面需要加逗号,。\n安装新版nodejs：\n\n# 1. 安装 nvm（如果还没安装）curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash# 或者wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash# 2. 重新打开终端，然后安装 Node.js 20nvm install 20nvm use 20# 设置为默认版本nvm alias default 20# 3. 验证版本node -v  # 应该显示 20.x.x \n","tags":["learning"]},{"title":"Hello World","url":"/1970/01/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"学习，工作，生活与热爱","url":"/2026/02/14/%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%B7%A5%E4%BD%9C%EF%BC%8C%E7%94%9F%E6%B4%BB%E4%B8%8E%E7%83%AD%E7%88%B1/","content":"一个人的行为应该是由他的价值观所决定的，当我们迷茫的时候，我们应该思考一下自己的价值观了。加缪说：“真正严肃的哲学问题只有一个，那就是自杀。”我们为什么还活着，我们真正看重的东西是什么，这就是我们人生的指南针。在大学以前，我的所有行为都是参考网络和身边观点的局部最优解，但是现在不一样了，现在的观点五花八门，自己没有明确的价值判断标准的时候，就会看哪个都觉得有道理。看完一本书，自认为恍然大悟，后来看到网上的评论说书里的案例都是胡编乱造的，就站到了对立面。因此左右脑互搏，做事情摇摆不定，连自己应该高兴还是伤心都不能确定。人在忙的时候是不会感受到无意义感的，因为这时只会想“忙完这件事，真正的生活就会开始”。然而事实上，真正的生活就是现在，就是忙的时候。\n学习我曾经想，等我有能力了，我要改革中国的教育制度，让中国的学生生活得更轻松幸福。批评高考、大学教育、原生家庭的文章我已经看了不少了，再看都有点厌倦了，指出问题的人很多，但是我不知道怎么做，这就产生了一种深深的无力感。我曾经想，我学习，应该是因为我热爱知识，并且获得新知识的过程也是快乐的。我喜欢创造，我喜欢用现有的工具设计自己的软件，我喜欢设计车灯，设计零食，布置自己的房间，设计最有性价比的购物选择，但是现在它们可以用人工智能来替代。我选择计算机是因为我喜欢它，但是学得深入之后我才发现我喜欢它的浅显知识和成熟应用的部分，我不喜欢深奥的原理，但是除了它我不知道还能选择什么。学习是为了找工作，我很不愿意承认。竞争激烈的行业总会驱使人没有看清方向就赶快前进，看清方向需要时间，大一进实验室的弊端就是不确定自己是否真的对这个研究方向感兴趣。其实看清了方向也不能保证自己选择的方向就是正确的，无论选择哪条路，都会有一部分不满意的地方，都会美化未选择的路。极致的内卷道路已经被探索出来了，但是我没有那么多的能量，亲人的评价和期待很高，但是他们的话权重不高，躺平也算一条出路，但是社会和亲人还是我心里的一道坎。遵从自己的内心，量力而行，才不会后悔。\n工作我曾经想，我一定要找一个work-life-balance的工作，但是无奈计算机行业的人太多，我看到的评价都是说工作时间长，强度大。现在，我只想要一个不会失业，相对轻松的工作了。我曾经想，等我有能力了，我要让中国的工人团结起来，用罢工和革命反抗压迫，普及八小时工作制，缩小贫富差距。建筑工地上搬砖的工人、大街上扫地的清洁工和医生老师应该是一样被尊重的，而不是像现在的社会风气一样看不起赚钱少的，这是我眼里的社会主义。我也看过很多反映社会问题的文章或者视频，比如失业、腐败和法律不公，同样地，我也有深深的无力感。我喜欢软件开发，我看到的评价是竞争激烈，晋升难，易失业。如果我在互联网兴起的时候毕业，或者大家不会因为钱而转行，那将是非常幸运的。现在的风口是人工智能，谁都无法预测等到自己毕业的时候风口是什么，随大流总是安心的。普通家庭出身的孩子，没有看透经济的目光，也没有太多的容错空间，如果选择了不好的专业，可能会导致他的收入很低，如果创业失败了，还有可能背负巨额债务，所以随大流是局部最优解。  \n生活我曾经想，等我有很多钱和很多时间的时候，我要环球旅行，我要看一看世界的多彩，对于高雅的艺术，我可能无法理解，但是我可以用身体感受不同的地方。大概从14岁开始，我不喜欢玩游戏了，游戏的输赢和排名没有什么意义，在固定的规则下完成任务也没有价值。我眼里的游戏已经成为了一种社交的工具，而不是热爱，如果两个人都玩一款游戏，那他们就可以在尴尬的聊天中找到一个难得的共同话题。正如我不能理解过生日的意义。人们非常害怕无聊，所谓的“生活”“休息”和“去玩”只是绞尽脑汁地想出一种逃避无聊和消磨时间的应急措施，或者是遵从本能地寻求单纯的快感，我不认为这是有意义的生活。但是在空闲时间，我也会不知道怎么度过。购物中心已经失去了印象中的吸引力，购买食物和服饰实在是无聊透顶，商场里的娱乐活动也寥寥无几，精神世界匮乏，只有消费主义在弥漫。刷短视频或者打麻将能给予短暂的快感，但是空虚更难忍受。在我眼里，给有需要的人提供实质性的帮助，了解之前从未了解的事物是有价值的生活。所以我愿意做志愿服务，愿意尝试新事物，去博物馆，不过大多是三分钟热度。探索生活的道路永远不会停止，我喜欢的活动也会变，书中给出的观点也各有特色，从事创造性的活动，为理想奉献……\n热爱我曾经想，我会终身奉行“追求源于热爱，极致源于梦想”。但是当热爱变成别人强迫自己完成的工作的时候，它可能就不再吸引人了。我想要的，是自由地探索我热爱的领域，如果发现我不喜欢的地方，我就逃避。很多时候，我分不清到底是因为擅长才热爱还是因为热爱才擅长。在热爱的领域里，自己不如别人优秀，不能成为放弃的理由。我不看重钱，我看重价值，做有价值的事，在什么情况下都能做。身体的伤病可以治疗，心理的、社会关系的痛苦可以调节，只要活着，我就有机会做有价值的事，我的生命就有意义。\n","tags":["thinking"]},{"title":"3D_Gaussian_Splatting笔记","url":"/2026/02/24/3D-Gaussian-Splatting%E7%AC%94%E8%AE%B0/","content":"原理Splatting\n渲染（Rendering）是计算机图形学中的核心环节，指将三维场景（3D Scene）通过计算转化为二维图像（2D Image）的过程。简单来说，就是“把3D模型变成2D画面”。\n在传统渲染中，物体表面由无数个三角形（面）拼接而成。而 Splatting 认为，物体表面也可以由无数个带有大小和颜色的“点”来构成。渲染时，计算机不再计算三角形的边和面，而是直接将这些“点”投影到屏幕上，并填充像素。\n步骤：\n选择雪球\n抛掷雪球：从3D到2D，得到足迹\n加以合成，形成最后的图像\n\n\n选择雪球：\n点是没有体积的，我们需要给点一个核，核可以是高斯/圆/正方体，使得它有体积，能够被投影。\n高斯椭球有很好的数学性质：仿射变换后高斯核仍然闭合，3D降维到2D后依然为高斯椭球。\n三维高斯分布，其概率分布的形状（想一下正态分布的y-x图像）由均值和协方差矩阵决定令为常数，  \n经过变形可以得到  \n显然这是一个椭球面的方程，当取不同常数时，椭球面不同，最终形成实心椭球。\n高斯分布的仿射变换：对于三维空间中的做仿射变换，有三维空间中的标准高斯分布为，因为三维高斯分布的协方差矩阵一定是正定对称矩阵，所以其可以被分解为（矩阵的合同变换），所以任意的高斯分布都可以看作是标准高斯分布经过仿射变换得到的。\n对于任意可逆的仿射变换Ax+b，它的线性变换矩阵A都可以被分解为缩放矩阵S和旋转矩阵R的乘积，以下是其推导过程：  \n仿射变换是否可逆，完全取决于其线性部分矩阵是否可逆，因为  可逆，故  是对称正定矩阵，可以正交对角化。其中 且 。定义。显然  也是对称正定的，是缩放矩阵。因为可逆，定义，，所以是正交矩阵，所以是旋转矩阵。\n\n\n所以协方差矩阵可以被分解def computeCov3D(scale, mod, rot):  # create scaling matrix  S = np.array(      [[scale[0] * mod, 0, 0], [0, scale[1] * mod, 0], [0, 0, scale[2] * mod]]  )  # normalize quaternion to get valid rotation  # we use rotation matrix  R = rot  # compute 3d world covariance matrix Sigma  M = np.dot(R, S)  cov3D = np.dot(M, M.T)  return cov3D\n\n\n\n抛掷观测变换：\n在计算机图形学中，观测变换（Viewing Transformation）包含了视图变换（View Transformation）和投影变换（Projection Transformation）两个阶段。\n模型变换和视图变换：\n在计算机图形学中，模型变换（Model Transformation）是指将三维模型从其局部坐标系（Model Space）变换到世界坐标系（World Space）的过程。视图变换（View Transformation）是指将场景中所有物体的坐标从世界坐标系（World Space）转换到相机坐标系（View Space）的过程。\n模型变换和视图变换都是仿射变换\n世界坐标系：\n高斯核中心：\n高斯核：\n是该高斯分布的协方差矩阵\n\n\n相机坐标系：\n高斯核中心：\n高斯核：\n均值：\n协方差矩阵：\n\n\n\n\n投影变换：\n投影变换通常是非线性变换\n相机坐标系：\n高斯核中心：\n高斯核：\n均值：\n协方差矩阵：\n\n\n投影变换后的坐标系：\n高斯核中心：\n高斯核：\n均值：这里我的理解是：，我们把高斯核中心移动到了中。 \n协方差矩阵：\n\n\n由于这一步是非线性、非仿射的，我们不能用来求出协方差矩阵。但是可以用雅可比矩阵来局部线性近似，从而\n雅可比矩阵的推导：\n\n\n\n视口变换：\n均值控制椭球的位置，协方差矩阵控制椭球的形状，在投影变换中，我们对协方差矩阵只做了从四棱锥到长方体的变换，并没有进行缩放和平移（从长方体到原点为中心的正方体的变换），椭球的形状是正常的，因此我们只需要对均值进行视口变换。  \n像素坐标系：\n均值：\n协方差矩阵：\n\n\n\n着色球谐函数\n球函数（Spherical Function）是定义在单位球面（即半径为1的球面）上的函数。它通常用球坐标表示，自变量是极角（θ）和方位角（φ），记作 。在数学上，球函数通常表示为：\n球函数描述的是球面上的某种属性分布，例如地球表面的温度、重力场，或者计算机图形学中物体表面的光照强度。由于球面是二维曲面，所以球函数只需要两个参数（θ, φ）就能确定。\n球谐函数（Spherical Harmonics）是定义在球面上的特殊函数，它构成了球面上的正交基，类似于傅里叶级数在圆上的作用。简单来说，它是球面上的“正弦波”和“余弦波”。通常表示为：。其中阶数越高，表达能力越强。任何定义在球面上的函数都可以用球谐函数的线性组合来近似表示（类似于傅里叶级数展开）。\n在3D-Gaussian-Splatting中点云颜色(R,G,B)使用球谐函数来表示其中是球谐函数，是系数，也是三维向量(R,G,B)，作者采用3阶球谐函数进行拟合，因此我们知道需要个参数。\n我的理解是：我们事先计算好了48个参数，因此现在的颜色只与相机位置和高斯椭球的位置（即均值）有关，这两个变量决定了球谐函数里的和，最终我们实现了对于不同的观测角度都有不同的颜色。\n\n实现训练总流程初始化\n从SfM点云初始化\n\nCOLMAP稀疏点云    ↓┌─────────────────────────────────────────────┐│ 1. 提取3D点位置                              ││    μᵢ = 点云中的点位置                       │└─────────────────────────────────────────────┘    ↓┌─────────────────────────────────────────────┐│ 2. 初始化颜色                                ││    cᵢ = 最近视角的平均颜色                    │└─────────────────────────────────────────────┘    ↓┌─────────────────────────────────────────────┐│ 3. 初始化不透明度                            ││    αᵢ = 0.1（较小初始值）                    │└─────────────────────────────────────────────┘    ↓┌─────────────────────────────────────────────┐│ 4. 初始化协方差矩阵                          ││    Σᵢ = 基于最近邻距离估计                   ││    或使用固定小值                            │└─────────────────────────────────────────────┘使用KNN法找到3近邻，半径是三近邻的距离的平均\n\n从随机位置初始化  \n使用场景：没有SfM点云时\n在场景边界内随机采样位置\n其他参数随机初始化\n\n\n对每一个点，我们有：\n均值（三维向量）\n协方差矩阵（三行三列矩阵）\n颜色（三维向量RGB）\n不透明度（一个数）\n\n\n\n迭代优化\n单次迭代流程\n\n迭代 t：┌─────────────────────────────────────────────┐│ 1. 前向传播                                  ││    - 可微光栅化                              ││    - 生成渲染图像 I_rendered                 │└─────────────────────────────────────────────┘    ↓┌─────────────────────────────────────────────┐│ 2. 损失计算                                  ││    L = L1(I_rendered, I_gt) +               ││        λ_ssim × L_ssim(I_rendered, I_gt)    │└─────────────────────────────────────────────┘    ↓┌─────────────────────────────────────────────┐│ 3. 反向传播                                  ││    - 计算梯度 ∇L                            ││    - 更新参数：                              ││      μ ← μ - lr_μ × ∇L/∇μ                 ││      c ← c - lr_c × ∇L/∇c                 ││      α ← α - lr_α × ∇L/∇α                 ││      Σ ← Σ - lr_Σ × ∇L/∇Σ                 │└─────────────────────────────────────────────┘    ↓┌─────────────────────────────────────────────┐│ 4. 密度控制（每N次迭代）                      ││    - 克隆/分割/剪枝                          │└─────────────────────────────────────────────┘\n\n训练循环伪代码\n\n# 伪代码示例def train_3dgs(images, cameras, iterations=30000):    # 初始化    gaussians = initialize_from_sfm(cameras)        for iteration in range(iterations):        # 随机选择一个视角        camera_idx = random.randint(0, len(cameras)-1)        camera = cameras[camera_idx]        image_gt = images[camera_idx]                # 前向传播：可微光栅化        image_rendered = rasterize(gaussians, camera)                # 损失计算        loss = L1_loss(image_rendered, image_gt) + \\               lambda_ssim * SSIM_loss(image_rendered, image_gt)                # 反向传播        loss.backward()                # 参数更新        optimizer.step()        optimizer.zero_grad()                # 密度控制（每100次迭代）        if iteration % 100 == 0 and iteration &lt; 15000:            densify_and_prune(gaussians)                # 定期保存        if iteration % 1000 == 0:            save_checkpoint(gaussians, iteration)\n渲染算法迭代流程的第一步：前向传播\n前向渲染流程输入：高斯点云 + 相机参数    ↓┌─────────────────────────────────────────────┐│ 1. 视锥剔除                                  ││    - 移除视锥外的点                          ││    - 减少计算量                              │└─────────────────────────────────────────────┘    ↓┌─────────────────────────────────────────────┐│ 2. 投影变换                                  ││    - 3D高斯 → 2D高斯                        ││    - 计算2D协方差矩阵                        │└─────────────────────────────────────────────┘    ↓┌─────────────────────────────────────────────┐│ 3. 深度排序                                  ││    - 按深度值排序                            ││    - 准备从前到后渲染                        │└─────────────────────────────────────────────┘    ↓┌─────────────────────────────────────────────┐│ 4. 光栅化                                    ││    - 对每个像素：                            ││      * 找到影响该像素的高斯点                ││      * 计算2D高斯值                         ││      * Alpha混合                             │└─────────────────────────────────────────────┘    ↓    输出图像\n视锥剔除\n对于某个相机，把所有的点进行视图变换，判断点是否在视锥里，如果在视锥里，把它放进列表。\n\n投影变换\n使用投影矩阵对视锥之内的点进行变换。计算出2D协方差矩阵。\n\n深度排序\n每个高斯有一个视图空间深度 (View Space Depth)，其指在图形学渲染管线中，从相机视角出发，一个3D点到相机平面的垂直距离。将高斯按深度重新排列。\n\n光栅化\n找到影响该像素的高斯点和计算2D高斯值：\n屏幕分块：将整个屏幕或渲染目标划分为固定大小的瓦片（例如 16×16 像素）。\n分配高斯点到瓦片：遍历所有高斯点，通过其2D协方差矩阵计算其影响的大致矩形范围，根据计算出的2D边界框，判断它会影响哪些瓦片，并将其索引添加到这些瓦片的关联列表中。\n这一步适合使用GPU并行计算。\n数据结构：最终得到一个数组或列表 tile_gaussian_lists[tile_id]，其中存储了所有可能影响该瓦片的高斯点索引。\n当需要查找影响像素 (x, y)的高斯点时：从 tile_gaussian_lists[tile_id]中取出所有可能影响该瓦片的高斯点索引列表。对于列表中的每个高斯点，进行精确的2D高斯权重计算。\n\n\nAlpha混合：\n根据球谐函数计算出高斯点的颜色\n对光线上的粒子颜色进行求和：$C =\\sum\\limits^{N}\\limits_{i=1}T_i \\alpha ic_i，T_i=\\prod\\limits^{i-1}{j=1}(1-\\alpha _j)，\\alpha _i=(1-\\exp(-\\sigma _i \\delta _i))$\n是光线碰到粒子（光线被粒子阻碍）的概率密度，是取样距离\n得到每个像素的颜色\n\n\n\n机器学习损失计算迭代流程第二步\n\nL1 损失（L1 Loss），在机器学习中也称为平均绝对误差，\nD-SSIM Loss（Structural Dissimilarity Loss）是一种基于结构相似性的图像质量评估指标\n损失函数\n\n反向传播迭代优化第三步\n\nStochastic Gradient Descent (SGD)，中文常译为随机梯度下降，是机器学习中最基础、最核心的优化算法之一。它的核心思想是利用随机抽取的单个样本（或小批量样本）的梯度来近似整个数据集的梯度，从而进行参数更新。\n\n密度控制\n克隆：\n触发条件：当某个高斯点的梯度（Gradient）​ 很大，且其位置（Position）​ 的梯度远大于其形状（Scale）​ 的梯度时。\n逻辑：梯度大意味着这个点对当前视图的贡献很大，但位置梯度大说明它“站错了地方”。此时，系统会复制一个完全相同的点，并让它们分别向不同的方向微调，从而更精确地覆盖该区域。\n\n\n分裂：\n触发条件：当某个高斯点的形状（Scale）​ 变得过大时。\n逻辑：一个点变得太大，说明它试图覆盖一个过大的区域，导致细节模糊。此时，系统会将它分裂成两个更小的点，分别继承原点的部分属性，从而提升局部的分辨率。\n\n\n剪枝：\n触发条件：不透明度过低，空间尺度过小 \n逻辑：视觉贡献可以忽略\n\n\n\n操作环境配置\n在AutoDL上租赁一台RTX3090的服务器，选择Miniconda - python 3.10的配置\n在VSCode里安装Remote SSH，使用Ctrl + Shift + P 输入Remote SSH: Add，添加新的SSH主机，输入登录命令\n再Ctrl+Shift+P连接，输入密码\n在终端里配置Git的用户名和密码，生成密钥，添加到Github上\n克隆仓库git clone git@github.com:graphdeco-inria/gaussian-splatting.git --recursive，这一步可能因网络问题失败，可以换国内镜像源\n输入nvcc --version检测已经安装CUDA SDK 11\n输入cd gaussian-splatting然后执行conda env create --file environment.yml\n这一步可能因为网络问题而失败。\n用colmap -h检测有没有COLMAP，如果没有，安装COLMAP，sudo apt update和sudo apt install colmap\n\n训练\n用FileZilla连接服务器(sftp)\n在gaussian_splatting下创建存放训练数据的文件夹，在文件夹里创建一个项目的文件夹，然后创建input文件夹\n把拍的照片用FileZilla放到input里\n返回gaussian_splatting，执行python convert.py -s &lt;location&gt;，location是input的父文件夹，这一步完成了COLMAP初始化稀疏点云\n执行python train.py -s &lt;location&gt;，这一步完成了训练\n在output文件夹下可以找到point_cloud.ply，一个是7000次训练，一个是30000次训练。\n使用supersplat - 导入ply文件查看，如果遇到权限不足的情况，在wsl里执行chmod 777 文件名，拖进去就行\n\n","tags":["learning"]}]